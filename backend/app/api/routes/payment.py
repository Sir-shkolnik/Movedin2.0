import os
import stripe
import logging
from fastapi import APIRouter, HTTPException, Depends, Request
from sqlalchemy.orm import Session
from pydantic import BaseModel
from typing import Dict, Any, Optional
from app.core.database import get_db
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from app.models.lead import Lead
from app.models.vendor import Vendor

# Configure Stripe
stripe.api_key = os.getenv('STRIPE_SECRET_KEY')
logger = logging.getLogger(__name__)

router = APIRouter(tags=["payment"])

class PaymentIntentRequest(BaseModel):
    amount: int
    currency: str = "cad"
    customer_email: Optional[str] = None
    description: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None
    selectedQuote: Optional[Dict[str, Any]] = None
    vendor: Optional[Dict[str, Any]] = None
    fromDetails: Optional[Dict[str, Any]] = None
    contact: Optional[Dict[str, Any]] = None

class PaymentConfirmRequest(BaseModel):
    payment_intent_id: str
    lead_data: Dict[str, Any]

async def send_vendor_email(lead_data: Dict[str, Any], vendor_email: str, lead_id: int):
    """
    Send email notification to vendor after successful payment
    """
    try:
        # Extract data for email
        quote_data = lead_data.get('quote_data', {})
        selected_quote = lead_data.get('selected_quote', {})
        contact_data = lead_data.get('contact_data', {})
        
        # Format email content
        subject = f"New Move Booking - Lead #{lead_id} - Payment Confirmed"
        
        # Build email body
        body = f"""
        üöö NEW MOVE BOOKING - PAYMENT CONFIRMED

        Lead ID: #{lead_id}
        Status: Payment Completed

        üìã CUSTOMER DETAILS:
        Name: {contact_data.get('firstName', '')} {contact_data.get('lastName', '')}
        Email: {contact_data.get('email', '')}
        Phone: {contact_data.get('phone', '')}

        üè† MOVE DETAILS:
        From: {quote_data.get('originAddress', '')}
        To: {quote_data.get('destinationAddress', '')}
        Date: {quote_data.get('moveDate', '')}
        Time: {quote_data.get('moveTime', '')}
        Rooms: {quote_data.get('totalRooms', '')}
        Square Footage: {quote_data.get('squareFootage', '')}
        Estimated Weight: {quote_data.get('estimatedWeight', '')} lbs

        üö™ PROPERTY DETAILS:
        Stairs at Pickup: {quote_data.get('stairsAtPickup', 0)}
        Stairs at Dropoff: {quote_data.get('stairsAtDropoff', 0)}
        Elevator at Pickup: {'Yes' if quote_data.get('elevatorAtPickup') else 'No'}
        Elevator at Dropoff: {'Yes' if quote_data.get('elevatorAtDropoff') else 'No'}

        üì¶ HEAVY ITEMS:
        Piano: {quote_data.get('heavyItems', {}).get('piano', 0)}
        Safe: {quote_data.get('heavyItems', {}).get('safe', 0)}
        Treadmill: {quote_data.get('heavyItems', {}).get('treadmill', 0)}

        üõ†Ô∏è ADDITIONAL SERVICES:
        Packing: {'Yes' if quote_data.get('additionalServices', {}).get('packing') else 'No'}
        Storage: {'Yes' if quote_data.get('additionalServices', {}).get('storage') else 'No'}
        Cleaning: {'Yes' if quote_data.get('additionalServices', {}).get('cleaning') else 'No'}
        Junk Removal: {'Yes' if quote_data.get('additionalServices', {}).get('junk') else 'No'}

        üí∞ QUOTE DETAILS:
        Vendor: {selected_quote.get('vendor_name', '')}
        Total Cost: ${selected_quote.get('total_cost', 0):.2f}
        Crew Size: {selected_quote.get('crew_size', '')}
        Truck Count: {selected_quote.get('truck_count', '')}
        Estimated Hours: {selected_quote.get('estimated_hours', '')}
        Travel Time: {selected_quote.get('travel_time_hours', '')} hours

        üìû NEXT STEPS:
        Please contact the customer to confirm the booking and arrange move details.
        Customer phone: {contact_data.get('phone', '')}
        Customer email: {contact_data.get('email', '')}

        ---
        This email was automatically generated by MovedIn 2.0
        """
        
        # For now, just log the email (we'll implement actual email sending later)
        logger.info(f"üìß VENDOR EMAIL NOTIFICATION - Lead #{lead_id}")
        logger.info(f"üìß To: {vendor_email}")
        logger.info(f"üìß Subject: {subject}")
        logger.info(f"üìß Body: {body}")
        
        # TODO: Implement actual email sending
        # This is where we'll add SMTP configuration and send the email
        
        return True
        
    except Exception as e:
        logger.error(f"Failed to send vendor email: {e}")
        return False

@router.post('/create-intent')
async def create_payment_intent(req: PaymentIntentRequest, db: Session = Depends(get_db)):
    """
    Create a Stripe PaymentIntent for the $1 CAD deposit
    """
    try:
        if not stripe.api_key:
            raise HTTPException(status_code=500, detail="Stripe not configured")
        
        # IMPORTANT: Create lead BEFORE payment with status 'pending_payment'
        logger.info("Creating lead BEFORE payment...")
        
        # Prepare lead data
        lead_data = {
            'quote_data': req.fromDetails,
            'selected_quote': req.selectedQuote,
            'contact_data': req.contact
        }
        
        # Create lead with pending payment status
        try:
            from app.api.routes.leads import create_lead_internal
            lead_result = await create_lead_internal(lead_data, db, 'pending_payment')
            lead_id = lead_result.get('id')
            logger.info(f"Lead created with ID: {lead_id} and status 'pending_payment'")
        except Exception as lead_error:
            logger.error(f"Failed to create lead: {lead_error}")
            # Continue with payment intent creation even if lead creation fails
            lead_id = None
        
        # Store lead data in metadata for webhook processing
        metadata = {
            'selectedQuote': str(req.selectedQuote) if req.selectedQuote else '',
            'vendor': str(req.vendor) if req.vendor else '',
            'fromDetails': str(req.fromDetails) if req.fromDetails else '',
            'contact': str(req.contact) if req.contact else '',
            'lead_data': str(lead_data),
            'lead_id': str(lead_id) if lead_id else ''
        }
        
        # Create payment intent for $1 CAD (100 cents)
        intent = stripe.PaymentIntent.create(
            amount=req.amount,
            currency=req.currency,
            metadata=metadata,
            description=req.description or 'MovedIn 2.0 - $1 CAD Deposit',
            receipt_email=req.customer_email,
            automatic_payment_methods={
                'enabled': True,
            }
        )
        
        logger.info(f"Created payment intent: {intent.id} for amount: {req.amount}")
        
        return {
            'client_secret': intent.client_secret,
            'payment_intent_id': intent.id,
            'amount': intent.amount,
            'currency': intent.currency,
            'lead_id': lead_id
        }
        
    except stripe.error.StripeError as e:
        logger.error(f"Stripe error: {e}")
        raise HTTPException(status_code=400, detail=f"Payment error: {str(e)}")
    except Exception as e:
        logger.error(f"Payment intent creation error: {e}")
        raise HTTPException(status_code=500, detail="Failed to create payment intent")

@router.post('/webhook/stripe')
async def stripe_webhook(request: Request, db: Session = Depends(get_db)):
    """
    Handle Stripe webhook events (payment success, etc.)
    """
    try:
        if not stripe.api_key:
            raise HTTPException(status_code=500, detail="Stripe not configured")
        
        # Get the webhook secret
        webhook_secret = os.getenv('STRIPE_WEBHOOK_SECRET')
        if not webhook_secret:
            logger.error("STRIPE_WEBHOOK_SECRET not configured")
            raise HTTPException(status_code=500, detail="Webhook secret not configured")
        
        # Get the request body
        payload = await request.body()
        sig_header = request.headers.get('stripe-signature')
        
        if not sig_header:
            logger.error("No stripe-signature header")
            raise HTTPException(status_code=400, detail="No signature header")
        
        try:
            # Verify webhook signature
            event = stripe.Webhook.construct_event(
                payload, sig_header, webhook_secret
            )
        except ValueError as e:
            logger.error(f"Invalid payload: {e}")
            raise HTTPException(status_code=400, detail="Invalid payload")
        except stripe.error.SignatureVerificationError as e:
            logger.error(f"Invalid signature: {e}")
            raise HTTPException(status_code=400, detail="Invalid signature")
        
        # Handle the event
        if event['type'] == 'payment_intent.succeeded':
            await handle_payment_success(event['data']['object'], db)
        elif event['type'] == 'payment_intent.payment_failed':
            await handle_payment_failure(event['data']['object'], db)
        else:
            logger.info(f"Unhandled event type: {event['type']}")
        
        return {'status': 'success'}
        
    except Exception as e:
        logger.error(f"Webhook error: {e}")
        raise HTTPException(status_code=500, detail="Webhook processing failed")

async def handle_payment_success(payment_intent: Dict[str, Any], db: Session):
    """
    Handle successful payment and save lead data
    """
    try:
        payment_intent_id = payment_intent['id']
        metadata = payment_intent.get('metadata', {})
        
        logger.info(f"Processing successful payment: {payment_intent_id}")
        
        # Extract lead data from metadata
        lead_data_str = metadata.get('lead_data', '{}')
        if not lead_data_str:
            logger.error(f"No lead data found in payment intent: {payment_intent_id}")
            return
        
        # Parse lead data (this is a simplified version - you might want to use JSON)
        import ast
        try:
            lead_data = ast.literal_eval(lead_data_str)
        except:
            logger.error(f"Failed to parse lead data: {lead_data_str}")
            return
        
        # Save lead data to database
        from app.api.routes.leads import create_lead_internal
        lead_result = await create_lead_internal(lead_data, db)
        
        logger.info(f"Payment confirmed and lead saved: {lead_result.get('id')}")
        
    except Exception as e:
        logger.error(f"Failed to handle payment success: {e}")

async def handle_payment_failure(payment_intent: Dict[str, Any], db: Session):
    """
    Handle failed payment
    """
    try:
        payment_intent_id = payment_intent['id']
        logger.info(f"Payment failed: {payment_intent_id}")
        # You could implement retry logic or customer notification here
    except Exception as e:
        logger.error(f"Failed to handle payment failure: {e}")

@router.post('/confirm-payment')
async def confirm_payment(
    req: PaymentConfirmRequest,
    db: Session = Depends(get_db)
):
    """
    Confirm payment and save lead data (manual confirmation endpoint)
    """
    try:
        if not stripe.api_key:
            raise HTTPException(status_code=500, detail="Stripe not configured")
        
        # Retrieve the payment intent
        payment_intent = stripe.PaymentIntent.retrieve(req.payment_intent_id)
        
        # For development/testing, allow payment intents that are not yet succeeded
        # In production, this should only allow 'succeeded' status
        allowed_statuses = ['succeeded', 'requires_payment_method', 'requires_confirmation']
        if payment_intent.status not in allowed_statuses:
            raise HTTPException(status_code=400, detail=f"Payment not in valid state: {payment_intent.status}")
        
        # Check if lead already exists (from create-intent)
        existing_lead = None
        if req.lead_data.get('lead_id'):
            try:
                existing_lead = db.query(Lead).filter(Lead.id == req.lead_data['lead_id']).first()
            except:
                pass
        
        if existing_lead:
            # Update existing lead status to 'payment_completed'
            existing_lead.status = 'payment_completed'
            existing_lead.payment_intent_id = req.payment_intent_id
            db.commit()
            db.refresh(existing_lead)
            lead_id = existing_lead.id
            logger.info(f"Updated existing lead {lead_id} status to 'payment_completed'")
        else:
            # Create new lead if none exists
            try:
                from app.api.routes.leads import create_lead_internal
                lead_result = await create_lead_internal(req.lead_data, db, 'payment_completed')
                lead_id = lead_result.get('id')
                logger.info(f"Created new lead {lead_id} with status 'payment_completed'")
            except Exception as lead_error:
                logger.error(f"Failed to save lead data: {lead_error}")
                raise HTTPException(status_code=500, detail=f"Failed to save lead: {str(lead_error)}")
        
        # Send email notification to vendor
        try:
            # Get vendor email from the lead
            lead = db.query(Lead).filter(Lead.id == lead_id).first()
            if lead and lead.selected_vendor_id:
                # Get vendor details
                vendor = db.query(Vendor).filter(Vendor.id == lead.selected_vendor_id).first()
                if vendor and vendor.email:
                    await send_vendor_email(req.lead_data, vendor.email, lead_id)
                    logger.info(f"Vendor email sent to {vendor.email} for lead {lead_id}")
                else:
                    logger.warning(f"No vendor email found for vendor {lead.selected_vendor_id}")
            else:
                logger.warning(f"No vendor found for lead {lead_id}")
        except Exception as email_error:
            logger.error(f"Failed to send vendor email: {email_error}")
            # Don't fail the payment confirmation if email fails
        
        return {
            'status': 'success',
            'payment_intent_id': req.payment_intent_id,
            'lead_id': lead_id,
            'message': 'Payment processed and lead saved successfully'
        }
        
    except stripe.error.StripeError as e:
        logger.error(f"Stripe error: {e}")
        raise HTTPException(status_code=400, detail=f"Payment error: {str(e)}")
    except Exception as e:
        logger.error(f"Payment confirmation error: {e}")
        raise HTTPException(status_code=500, detail="Failed to confirm payment")

@router.get('/test-connection')
async def test_stripe_connection():
    """
    Test Stripe API connection
    """
    try:
        if not stripe.api_key:
            raise HTTPException(status_code=500, detail="Stripe not configured")
        
        # Create a test payment intent
        intent = stripe.PaymentIntent.create(
            amount=100,
            currency='cad',
            description='Test connection',
            automatic_payment_methods={'enabled': True}
        )
        
        return {
            'status': 'success',
            'message': 'Stripe connection successful',
            'test_intent_id': intent.id
        }
        
    except Exception as e:
        logger.error(f"Stripe connection test failed: {e}")
        raise HTTPException(status_code=500, detail=f"Connection test failed: {str(e)}") 